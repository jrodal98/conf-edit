#!/usr/bin/env python3
import os
import sys
import json
import subprocess
import shlex
import argparse


def print_and_exit(msg):
    """
    Convenient function for printing an error message and stopping execution.
    """
    print(msg, file=sys.stderr)
    sys.exit(1)


"""
Handles most of the conf-edit logic
"""


class Config:
    def __init__(self, test=False):
        self.default_editor = ""  # default text editor specified by user
        if not test:
            home = os.path.expanduser("~")
            # conf-edit configuration path
            self.config_path = f"{home}/.config/conf-edit/config"
        else:
            self.config_path = "conf-edit-test-config"
        # stores the name of the files and info related to them (path, editor,
        # hook)
        self.actions = {}
        if not os.path.isfile(self.config_path):
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            # generate a conf-edit config if there isn't one yet
            self.generate_default_config(self.default_editor)
        self.actions = self.read_config()

    def update_config(self):
        with open(self.config_path, "w") as f:
            data = [self.default_editor, self.actions, ]
            json.dump(data, f, indent=4)

    def generate_default_config(self, editor=""):
        # 1. get a default editor
        self.set_default_editor(editor)
        self.generate_entry("conf-edit", self.config_path,
                            hook="echo 'conf-edit config edited!'")

    def generate_entry(self, name, path, editor="", hook="", replace=False):
        if not editor:
            editor = self.default_editor
        if name in self.actions and not replace:
            print_and_exit(
                f"You already have an entry named {name} - did you mean to \
                use replace?")
        self.actions[name] = {"path": path, "editor": editor, "hook": hook}
        self.update_config()

    def read_config(self):
        with open(self.config_path) as f:
            data = json.load(f)
        assert isinstance(data[0], str)
        self.default_editor = data[0]
        return data[1]

    def perform_add(self, path, name, editor=None, hook=None):
        self.generate_entry(name, path, editor, hook)
        print(f"Entry for {name} generated!", file=sys.stderr)

    def perform_replace(self, current_name, path, name, editor, hook):
        old_path = self.actions[current_name]["path"]
        old_editor = self.actions[current_name]["editor"]
        old_hook = self.actions[current_name]["hook"]
        self.generate_entry(name or current_name, path or old_path,
                            editor or old_editor, hook or old_hook, True)
        if current_name != name:
            self.perform_remove(current_name)
        print(f"Entry for {name} edited!", file=sys.stderr)

    def perform_remove(self, name):
        if name in self.actions:
            del self.actions[name]
            self.update_config()
            print(f"{name} removed.", file=sys.stderr)
        else:
            print_and_exit(f"{name} is not a valid entry.")

    def perform_list(self):
        print("{:<15} {:<50}".format('Name', 'Path'))
        for name, v in self.actions.items():
            print("{:<15} {:<50}".format(name, v["path"]))

    def run_posthook(self, name, action_data):
        hook = action_data["hook"]
        if action_data["path"] == self.config_path:
            self.actions = self.read_config()
            new_data = self.actions.get(name, None)
            if new_data["path"] == action_data["path"]:
                hook = new_data["hook"]
        if hook:
            try:
                subprocess.run(shlex.split(hook))
            except Exception as e:
                print(str(e))
                print_and_exit(
                    f"Error attempting to run hook for {name}.  Check your \
                            conf-edit configuration to verify that hook\
                            is valid.")

    def perform_edit(self, name, view=False):
        action_data = self.actions.get(name, None)
        if None:
            print_and_exit(
                f"{name} not found - did you add it to the conf-edit config?\
                        If not, run conf-edit add {name}")
        try:
            subprocess.run([action_data["editor"], action_data["path"]])
        except Exception:
            print_and_exit(
                f"Error attempting to edit {name}.  Check your\
                        conf-edit configuration.")
        if not view:
            self.run_posthook(name, action_data)

    def perform_execute(self, name, view=False):
        action_data = self.actions.get(name, None)
        if None:
            print_and_exit(
                f"{name} not found - did you add it to the conf-edit config?\
                        If not, run conf-edit add {name}")
        self.run_posthook(name, action_data)

    def set_default_editor(self, editor):
        if editor:
            if not os.path.isfile(editor):
                if not os.path.isfile(f"/usr/bin/{editor}"):
                    print_and_exit(
                        f"Could not find {editor}.  Provide a full path. (e.g.\
                                /usr/bin/nano)")
                else:
                    editor = f"/usr/bin/{editor}"
            print(f"Setting {editor} as the default editor", file=sys.stderr)
            self.default_editor = editor
        else:
            for option in (f"/usr/bin/{x}" for x in ("vim", "emacs", "nano",
                                                     "gedit", "micro")):
                if os.path.isfile(option):
                    print(
                        f"Setting {option} as the default editor",
                        file=sys.stderr)
                    self.default_editor = option
                    break
            if not option:
                print_and_exit(
                    f"Could not find a valid editor.  Provide a full path.\
                            (e.g. /usr/bin/nano)")


if __name__ == "__main__":
    config = Config()

    if len(sys.argv) == 1:
        config.perform_list()
        sys.exit(0)

    action = sys.argv[1]
    parser = argparse.ArgumentParser()
    commands = ("add", "remove", "rm", "ls", "view",
                "execute", "replace", "set-editor")
    parser.add_argument('action',
                        help='Thing todo.  Options: {}, or name of file'
                        .format(", ".join(commands)))
    if action == "add":
        parser.add_argument("path", help="Path to the file.")
        parser.add_argument(
            "-n", "--name", help="Name of the command you want to\
                    associate the file with.")
        parser.add_argument(
            "-e", "--editor", help="Editor associated with the file.")
        parser.add_argument(
            "-s", "--script", help="Command ran after file is edited")
        args = parser.parse_args()
        if not args.path:
            print_and_exit(
                "You must provide the path to the file you want\
                        to create an entry for.")

        path = os.path.abspath(args.path)
        name = args.name if args.name else os.path.basename(path)
        if name in commands:
            print_and_exit(
                f"You can't use '{name}' as a name - it's a reserved keyword.")

        config.perform_add(path, name, args.editor, args.script)
    elif action == "replace":
        parser.add_argument("current_name", help="Name of the entry.")
        parser.add_argument(
            "-n", "--name", help="New name of the command you want to\
                    associate the file with.")
        parser.add_argument("-p", "--path", help="New path to the file.")
        parser.add_argument(
            "-e", "--editor", help="New Editor associated with the file.")
        parser.add_argument(
            "-s", "--script", help="New Command ran after file is edited\
                    (post edit hook).")
        args = parser.parse_args()
        if not args.current_name:
            print_and_exit(
                "You must provide the name of the entry you want to replace.")

        path = os.path.abspath(args.path) if args.path else None
        name = args.name if args.name else args.current_name
        if name in commands:
            print_and_exit(
                f"You can't use '{name}' as a name - it's a reserved keyword.")

        config.perform_replace(args.current_name, path,
                               name, args.editor, args.script)
    elif action == "remove" or action == "rm":
        parser.add_argument(
            "name", help="Name of the command the file is associated with.")
        args = parser.parse_args()
        if not args.name:
            print_and_exit("You must provide the name of the entry to remove.")
        config.perform_remove(args.name)
    elif action == "ls":
        config.perform_list()
    elif action == "execute":
        parser.add_argument(
            "name", help="Name of the command the file is associated with.")
        args = parser.parse_args()
        if not args.name:
            print_and_exit(
                "You must provide the name of the entry whose posthook\
                        you wish to execute.")
        config.perform_execute(args.name)
    elif action == "set-editor":
        parser.add_argument("editor", help="Path to the editor.")
        args = parser.parse_args()
        config.set_default_editor(args.editor)
        config.update_config()

    else:
        parser.add_argument("-v", "--view", action='store_true',
                            help="Open file in view mode (don't run posthook)")
        args = parser.parse_args()
        config.perform_edit(action, args.view)

